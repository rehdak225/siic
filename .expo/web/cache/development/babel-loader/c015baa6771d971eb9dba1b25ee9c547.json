{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { InterruptionModeAndroid, InterruptionModeIOS } from \"./Audio.types\";\nimport ExponentAV from \"./ExponentAV\";\nexport * from \"./Audio/Recording\";\nexport * from \"./Audio/Sound\";\nexport { setIsEnabledAsync } from \"./Audio/AudioAvailability\";\nexport { PitchCorrectionQuality } from \"./AV\";\n\nvar _populateMissingKeys = function _populateMissingKeys(userAudioMode, defaultAudioMode) {\n  for (var key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n\n  return userAudioMode;\n};\n\nvar defaultMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false\n};\nvar currentAudioMode = null;\n\nfunction getCurrentAudioMode() {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n\n  return currentAudioMode;\n}\n\nexport function setAudioModeAsync(partialMode) {\n  var mode;\n  return _regeneratorRuntime.async(function setAudioModeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n\n          if (InterruptionModeIOS[mode.interruptionModeIOS]) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new Error(\"\\\"interruptionModeIOS\\\" was set to an invalid value.\");\n\n        case 3:\n          if (InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n            _context.next = 5;\n            break;\n          }\n\n          throw new Error(\"\\\"interruptionModeAndroid\\\" was set to an invalid value.\");\n\n        case 5:\n          if (!(typeof mode.allowsRecordingIOS !== 'boolean' || typeof mode.playsInSilentModeIOS !== 'boolean' || typeof mode.staysActiveInBackground !== 'boolean' || typeof mode.shouldDuckAndroid !== 'boolean' || typeof mode.playThroughEarpieceAndroid !== 'boolean')) {\n            _context.next = 7;\n            break;\n          }\n\n          throw new Error('\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.');\n\n        case 7:\n          currentAudioMode = mode;\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(ExponentAV.setAudioMode(mode));\n\n        case 10:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/Audio.ts"],"names":[],"mappings":";AAAA,SAAoB,uBAApB,EAA6C,mBAA7C;AACA,OAAO,UAAP;AAEA;AACA;AACA,SAAS,iBAAT;AACA,SAAS,sBAAT;;AAEA,IAAM,oBAAoB,GAAG,SAAvB,oBAAuB,CAC3B,aAD2B,EAE3B,gBAF2B,EAGd;AACb,OAAK,IAAM,GAAX,IAAkB,gBAAlB,EAAoC;AAClC,QAAI,CAAC,aAAa,CAAC,cAAd,CAA6B,GAA7B,CAAL,EAAwC;AACtC,MAAA,aAAa,CAAC,GAAD,CAAb,GAAqB,gBAAgB,CAAC,GAAD,CAArC;AACD;AACF;;AACD,SAAO,aAAP;AACD,CAVD;;AAYA,IAAM,WAAW,GAAc;AAC7B,EAAA,kBAAkB,EAAE,KADS;AAE7B,EAAA,mBAAmB,EAAE,mBAAmB,CAAC,aAFZ;AAG7B,EAAA,oBAAoB,EAAE,KAHO;AAI7B,EAAA,uBAAuB,EAAE,KAJI;AAK7B,EAAA,uBAAuB,EAAE,uBAAuB,CAAC,UALpB;AAM7B,EAAA,iBAAiB,EAAE,IANU;AAO7B,EAAA,0BAA0B,EAAE;AAPC,CAA/B;AAUA,IAAI,gBAAgB,GAAqB,IAAzC;;AAEA,SAAS,mBAAT,GAA4B;AAC1B,MAAI,CAAC,gBAAL,EAAuB;AACrB,WAAO,WAAP;AACD;;AACD,SAAO,gBAAP;AACD;;AAED,OAAO,SAAe,iBAAf,CAAiC,WAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AACC,UAAA,IADD,GACQ,oBAAoB,CAAC,WAAD,EAAc,mBAAmB,EAAjC,CAD5B;;AAAA,cAGA,mBAAmB,CAAC,IAAI,CAAC,mBAAN,CAHnB;AAAA;AAAA;AAAA;;AAAA,gBAIG,IAAI,KAAJ,wDAJH;;AAAA;AAAA,cAMA,uBAAuB,CAAC,IAAI,CAAC,uBAAN,CANvB;AAAA;AAAA;AAAA;;AAAA,gBAOG,IAAI,KAAJ,4DAPH;;AAAA;AAAA,gBAUH,OAAO,IAAI,CAAC,kBAAZ,KAAmC,SAAnC,IACA,OAAO,IAAI,CAAC,oBAAZ,KAAqC,SADrC,IAEA,OAAO,IAAI,CAAC,uBAAZ,KAAwC,SAFxC,IAGA,OAAO,IAAI,CAAC,iBAAZ,KAAkC,SAHlC,IAIA,OAAO,IAAI,CAAC,0BAAZ,KAA2C,SAdxC;AAAA;AAAA;AAAA;;AAAA,gBAgBG,IAAI,KAAJ,CACJ,iJADI,CAhBH;;AAAA;AAoBL,UAAA,gBAAgB,GAAG,IAAnB;AApBK;AAAA,2CAqBQ,UAAU,CAAC,YAAX,CAAwB,IAAxB,CArBR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import { AudioMode, InterruptionModeAndroid, InterruptionModeIOS } from './Audio.types';\nimport ExponentAV from './ExponentAV';\n\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\n\nconst _populateMissingKeys = (\n  userAudioMode: Partial<AudioMode>,\n  defaultAudioMode: AudioMode\n): AudioMode => {\n  for (const key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode as AudioMode;\n};\n\nconst defaultMode: AudioMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false,\n};\n\nlet currentAudioMode: AudioMode | null = null;\n\nfunction getCurrentAudioMode(): AudioMode {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\n\nexport async function setAudioModeAsync(partialMode: Partial<AudioMode>): Promise<void> {\n  const mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n\n  if (!InterruptionModeIOS[mode.interruptionModeIOS]) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (!InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.staysActiveInBackground !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean' ||\n    typeof mode.playThroughEarpieceAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  currentAudioMode = mode;\n  return await ExponentAV.setAudioMode(mode);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}